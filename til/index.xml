<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tils on GeekyRyan</title><link>https://rnemeth90.github.io/til/</link><description>Recent content in Tils on GeekyRyan</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Mon, 08 Dec 2025 16:01:00 +0000</lastBuildDate><atom:link href="https://rnemeth90.github.io/til/index.xml" rel="self" type="application/rss+xml"/><item><title>2s Complement</title><link>https://rnemeth90.github.io/til/2025-12-08-twoscomplement/</link><pubDate>Mon, 08 Dec 2025 16:01:00 +0000</pubDate><guid>https://rnemeth90.github.io/til/2025-12-08-twoscomplement/</guid><description>&lt;p&gt;Two&amp;rsquo;s Complement is required for representing signed integers. If the high bit is 1 (i.e. if the binary number is 128 or greater in an 8-bit system), then the number is negative. To find the negative value, invert all bits and add 1.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;p&gt;To convert the binary number &lt;code&gt;11111010&lt;/code&gt; to decimal:&lt;/p&gt;
&lt;p&gt;First, invert all the bits: &lt;code&gt;00000101&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Then, add 1: &lt;code&gt;00000101 + 1 = 00000110&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Finally, convert to decimal: &lt;code&gt;6&lt;/code&gt;&lt;/p&gt;</description></item><item><title>Integer Overflow</title><link>https://rnemeth90.github.io/til/2015-12-08-integer-overflow/</link><pubDate>Mon, 08 Dec 2025 16:01:00 +0000</pubDate><guid>https://rnemeth90.github.io/til/2015-12-08-integer-overflow/</guid><description>&lt;p&gt;Consider an 8-bit system. What happens when you add &lt;code&gt;1&lt;/code&gt; to the maximum value of &lt;code&gt;255&lt;/code&gt; (&lt;code&gt;11111111&lt;/code&gt; in binary)? An integer overflow occurs. The 8 bit result becomes &lt;code&gt;00000000&lt;/code&gt; because only 8 bits are kept.&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;11111111
+00000001
---------
1 00000000 &amp;lt; 9th bit carry-out
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The carry bit is then set in the CPUs eflags register, indicating that an overflow has occurred. Decisions can then be made by the CPU based on this flag.&lt;/p&gt;</description></item><item><title>Linux initramfs</title><link>https://rnemeth90.github.io/til/2025-10-31-initramfs/</link><pubDate>Fri, 31 Oct 2025 16:01:00 +0000</pubDate><guid>https://rnemeth90.github.io/til/2025-10-31-initramfs/</guid><description>&lt;p&gt;The initramfs (initial RAM filesystem) is a temporary in-memory filesystem used for systems that do not know in advance certain things about their hardware at boot time. It is used to bootstrap the real root filesystem and provide necessary drivers and tools to mount it.&lt;/p&gt;
&lt;p&gt;Some examples of when an initramfs is needed include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Systems that use encrypted root filesystems, where the initramfs contains the tools to prompt for a decryption key.&lt;/li&gt;
&lt;li&gt;Systems that boot from network filesystems, where the initramfs contains the necessary network drivers&lt;/li&gt;
&lt;li&gt;Systems that use complex storage setups like LVM or RAID, where the initramfs contains the tools to assemble these setups before mounting the root filesystem.&lt;/li&gt;
&lt;li&gt;Systems that require specific drivers for storage devices that are not built into the kernel, where the initramfs contains these drivers.&lt;/li&gt;
&lt;li&gt;Systems that need to perform specific setup tasks before mounting the root filesystem, such as checking filesystem integrity or loading firmware.&lt;/li&gt;
&lt;li&gt;Systems that boot from removable media, where the initramfs contains the necessary drivers to access the media.&lt;/li&gt;
&lt;li&gt;Systems that need to support multiple root filesystem types, where the initramfs contains the necessary tools to handle these types.&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Anacron</title><link>https://rnemeth90.github.io/til/2025-08-24-anacron/</link><pubDate>Sun, 24 Aug 2025 00:00:00 +0000</pubDate><guid>https://rnemeth90.github.io/til/2025-08-24-anacron/</guid><description>&lt;p&gt;Anacron is designed for tasks that need to run periodically (daily, weekly, monthly) on systems that are not continuously powered on. If a scheduled cron task is missed because the system is off, anacron will run the task once the system is available.&lt;/p&gt;
&lt;p&gt;On many systems, anacron is pre-installed. If not, install it with:&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;$ sudo apt install anacron
Anacron&amp;#39;s configuration is in the /etc/anacrontab file, which includes helpful comments and examples. Hereâ€™s an excerpt:

$ sudo vim /etc/anacrontab
# See anacron(8) and anacrontab(5) for details.
# These entries replace cron&amp;#39;s job entries.
1 5 cron.daily run-parts --report /etc/cron.daily
7 10 cron.weekly run-parts --report /etc/cron.weekly
@monthly 15 cron.monthly run-parts --report /etc/cron.monthly
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The syntax in the anacrontab file consists of four fields:&lt;/p&gt;</description></item><item><title>Linux Process Control Blocks</title><link>https://rnemeth90.github.io/til/2025-08-23-linux-pcb/</link><pubDate>Sat, 23 Aug 2025 16:01:00 +0000</pubDate><guid>https://rnemeth90.github.io/til/2025-08-23-linux-pcb/</guid><description>&lt;p&gt;The process control block in Linux (formally named the task_struct) is a data structure maintained by the kernel that contains all of the necessary information to maintain a process on the system. The task_struct is a large struct in the kernel containing many fields. Some example fields are process id (pid), file descriptors, environment variables, the command used to start the process, memory maps, etc. The information specific to a process can be viewed in the &lt;code&gt;/proc/&amp;lt;pid&amp;gt;/&lt;/code&gt; directory. You can learn more in the man pages &lt;code&gt;man procfs&lt;/code&gt;. You can find other relevant man pages with &lt;code&gt;apropos proc&lt;/code&gt;&lt;/p&gt;</description></item></channel></rss>