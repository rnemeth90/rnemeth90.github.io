<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Networking on GeekyRyan</title><link>https://rnemeth90.github.io/tags/networking/</link><description>GeekyRyan (Networking)</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 27 Nov 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://rnemeth90.github.io/tags/networking/index.xml" rel="self" type="application/rss+xml"/><item><title>Exploring Netcat</title><link>https://rnemeth90.github.io/posts/2023-11-27-netcat/</link><pubDate>Mon, 27 Nov 2023 00:00:00 +0000</pubDate><guid>https://rnemeth90.github.io/posts/2023-11-27-netcat/</guid><description>&lt;h2 id="introduction" >Introduction
&lt;span>
&lt;a href="#introduction">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Netcat is a versatile networking utility that can be used for a wide range of tasks. It has often been referred to as the &amp;ldquo;network swiss-army knife&amp;rdquo;. Netcat was first released in the mid-90s, and I personally find it ironic to be blogging about it in 2023! But I feel like it is a somewhat cryptic tool, and new engineers or college graduates may not be familiar. This article is meant for those people who are not familiar with it, or have only briefly been exposed.&lt;/p>
&lt;p>Netcat is a simple utility that reads and writes data across raw TCP/UDP sockets. Netcat is a command-line tool available out of the box on most *nix operating systems and can also be installed on Windows. It&amp;rsquo;s a powerful tool for debugging and investigating networks. It can even be used for tasks like port scanning, transferring files, chatting with friends on a network, and even creating backdoors (for testing purposes, obviously :) ).&lt;/p>
&lt;h2 id="understanding-udp" >Understanding UDP
&lt;span>
&lt;a href="#understanding-udp">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Before we dive into exploring UDP connections with netcat, let&amp;rsquo;s quickly get a refresher on UDP. UDP is a connectionless transport layer protocol that does not provide the same reliability, flow-control, and error-checking mechanisms as TCP. Unlike TCP, UDP also does not establish a persistent connection between the sender and receiver. Instead, it sends data packets, known as datagrams, individually using a &amp;lsquo;fire and forget&amp;rsquo; method. UDP is often used for applications where real-time communication and low overhead are crucial, such as streaming media, gaming, DNS (though, certain functions of DNS may also use TCP), and IoT devices.&lt;/p>
&lt;h2 id="understanding-tcp" >Understanding TCP
&lt;span>
&lt;a href="#understanding-tcp">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>It&amp;rsquo;s also crucial to have a fundamental knowledge of the TCP protocol. TCP is one of the main protocols in the Internet protocol suite, laying the foundation for the majority of data exchange over the Internet. Unlike its counterpart, UDP (User Datagram Protocol), TCP is connection-oriented, meaning a connection is established and maintained until the application programs at each end have finished exchanging messages. This ensures reliable, ordered, and error-checked delivery of a stream of data between applications running on hosts communicating over an IP network. Key features of TCP include its ability to manage data packet size, data transfer rate, and network traffic congestion, making it ideal for applications where data integrity and accuracy are crucial, such as web browsing, email, and file transfer. Understanding TCP is essential for effectively utilizing tools like Netcat, as it provides the basis for establishing stable and secure connections across a network.&lt;/p>
&lt;h2 id="creating-a-simple-clientserver" >Creating a Simple Client/Server
&lt;span>
&lt;a href="#creating-a-simple-clientserver">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>The following will create a simple UDP server and client.&lt;/p>
&lt;ol>
&lt;li>Launch a shell and type the following command. This will tell netcat to listen (&lt;code>-l&lt;/code>) on UDP (&lt;code>-u&lt;/code>) port (&lt;code>-p&lt;/code>) 5555.&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>nc -l -u -p 5555
&lt;/code>&lt;/pre>&lt;ol start="2">
&lt;li>Launch another shell and type the following. This will connect to the server we created above.&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>nc -u 127.0.0.1 5555
&lt;/code>&lt;/pre>&lt;ol start="3">
&lt;li>You can now send messages to the server, like so:&lt;/li>
&lt;/ol>
&lt;p>Client:&lt;/p>
&lt;pre tabindex="0">&lt;code>$ nc -u 127.0.0.1 5555
hello
&lt;/code>&lt;/pre>&lt;p>Server:&lt;/p>
&lt;pre tabindex="0">&lt;code>$ nc -l -u -p 5555
hello
&lt;/code>&lt;/pre>&lt;p>You can do the same thing with TCP, just leave out the &lt;code>-u&lt;/code> in each command above.&lt;/p>
&lt;h2 id="transfer-a-file" >Transfer a File
&lt;span>
&lt;a href="#transfer-a-file">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>On the receiving end:&lt;/p>
&lt;pre tabindex="0">&lt;code>nc -l -p 5555 &amp;gt; outputfile
&lt;/code>&lt;/pre>&lt;p>On the sending end:&lt;/p>
&lt;pre tabindex="0">&lt;code>nc [hostname or IP address of server] 5555 &amp;lt; inputfile
&lt;/code>&lt;/pre>&lt;h2 id="port-scanning" >Port Scanning:
&lt;span>
&lt;a href="#port-scanning">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;pre tabindex="0">&lt;code>netcat -v -z -n -w 1 v.txvip1 1-1023
&lt;/code>&lt;/pre>&lt;h2 id="serve-a-web-page" >Serve a web page:
&lt;span>
&lt;a href="#serve-a-web-page">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>If you have an html file, you can create a simple web server for it. Here we tell netcat to listen on port 8080 and redirect the contents of index.html to any &amp;rsquo;thing&amp;rsquo; that connects:&lt;/p>
&lt;pre tabindex="0">&lt;code>nc -l -p 8080 &amp;lt; index.html
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Note&lt;/strong>: In the examples above, I always use port 5555. You can technically use just about any port you want. However, attempting to use any port below 1024 will require root privileges. The port you choose cannot be in use by another process.&lt;/p>
&lt;h2 id="other-practical-examples" >Other Practical Examples
&lt;span>
&lt;a href="#other-practical-examples">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Let&amp;rsquo;s explore a few more practical examples to illustrate the usefulness of netcat&amp;rsquo;s UDP capabilities. I will leave the actual implementation as an exercise for you to try.&lt;/p>
&lt;h3 id="example-1-testing-a-tcpudp-server" >Example 1: Testing a TCP/UDP Server
&lt;span>
&lt;a href="#example-1-testing-a-tcpudp-server">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>Suppose you are developing a UDP server application, and you want to test its functionality. You can use netcat to send TCP/UDP packets to your server and observe its response. By monitoring the server&amp;rsquo;s behavior, you can ensure that it correctly handles incoming UDP traffic.&lt;/p>
&lt;h3 id="example-2-interacting-with-networked-devices" >Example 2: Interacting with Networked Devices
&lt;span>
&lt;a href="#example-2-interacting-with-networked-devices">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>Netcat can be handy when interacting with networked devices, such as routers, IoT devices, or even network-enabled printers. By establishing a TCP/UDP connection, you can send commands, queries, or configuration data to these devices, enabling you to troubleshoot or configure them remotely.&lt;/p>
&lt;h3 id="example-3-banner-grabbing" >Example 3. Banner Grabbing
&lt;span>
&lt;a href="#example-3-banner-grabbing">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>This is a technique used in network security to gather information about a remote server, including the type and version of the operating system and applications running. The basic concept is that you connect to a network service and see what kind of &amp;lsquo;banner&amp;rsquo; (if any) it returns in the output. When I was starting out in the IT world, this was a common thing to do to enumerate devices and services on a network. Though, I would like to believe this is no longer as much of a concern, given the simplicity of preventing this type of information discovery attack.&lt;/p>
&lt;h2 id="conclusion" >Conclusion
&lt;span>
&lt;a href="#conclusion">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Netcat&amp;rsquo;s ability to handle UDP connections makes it an invaluable tool for various network-related tasks. Whether you are testing a UDP server, interacting with networked devices, or exploring your network&amp;rsquo;s services, netcat provides a convenient and straightforward approach.&lt;/p>
&lt;p>In this blog post, we walked through the process of creating a UDP connection using netcat, discussed the fundamentals of UDP, and explored practical examples where netcat can prove useful. By mastering netcat&amp;rsquo;s capabilities, you can enhance your network troubleshooting and debugging skills, and gain a deeper understanding of UDP communication.&lt;/p>
&lt;p>You can read more about netcat in the man pages:&lt;/p>
&lt;pre tabindex="0">&lt;code>man nc
&lt;/code>&lt;/pre>&lt;p>The OpenBSD repository contains the original source written by Hobbit decades ago:
&lt;a href="https://github.com/openbsd/src/blob/master/usr.bin/nc/netcat.c">netcat.c&lt;/a>&lt;/p></description></item><item><title>Azure VM Scale Set &amp;#8211; Get Instance IP Address</title><link>https://rnemeth90.github.io/posts/2020-11-19-azure-vm-scale-set-get-instance-ip/</link><pubDate>Thu, 19 Nov 2020 18:07:00 +0000</pubDate><guid>https://rnemeth90.github.io/posts/2020-11-19-azure-vm-scale-set-get-instance-ip/</guid><description>&lt;p>If you are using VM Scale Sets in Azure, you know how important it can be to quickly obtain an instance IP address. This can of course be done using the Azure Portal. However, I am often working in a shell or VSCode, and I do not want to leave the comfort of my shell to login to the portal.&lt;/p>
&lt;p>There are a few options we have for retrieving information about a VMSS and its instances without using the Azure Portal. We can use PowerShell or the Azure CLI. Being that I am constantly flipping between Windows and Linux, I will detail both here.&lt;/p>
&lt;p>You will need to have the AZ module installed. To install this module, simple open PowerShell (as admin) and type in “Install-Module -Name az”. To get the IP address of the instances within a scale set, use the following script:&lt;/p>
&lt;p>&lt;a href="https://github.com/rnemeth90/Get-VmssInstanceIpAddress">https://github.com/rnemeth90/Get-VmssInstanceIpAddress&lt;/a>&lt;/p>
&lt;p>You can also use the Azure CLI to obtain individual instance IP addresses. This method is much simpler than PowerShell, and only requires one line of code:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>az vmss nic list –resource-group myResourceGroup –vmss-name myVmss | grep –w “privateIpAddress”
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Cisco AnyConnect &amp;#8211; VPN Establishment Capability from a Remote Desktop is Disabled</title><link>https://rnemeth90.github.io/posts/2020-10-07-cisco-anyconnect-vpn-establishment/</link><pubDate>Wed, 07 Oct 2020 13:28:00 +0000</pubDate><guid>https://rnemeth90.github.io/posts/2020-10-07-cisco-anyconnect-vpn-establishment/</guid><description>&lt;p>I ran into this issue this morning when attempting to setup a VPN on a Hyper-V virtual machine. After an hour of searching the Google machine and troubleshooting, I came upon this solution.&lt;/p>
&lt;p>&lt;a href="https://lh3.googleusercontent.com/-BYApW8vZjV8/X33B2Or4D7I/AAAAAAAAxuY/hWQwpE-fqo4xInAsx9vyUvzDJXqxe68QQCLcBGAsYHQ/image.png">&lt;img src="https://rnemeth90.github.io/wp-content/uploads/2020/10/image-16.png" alt="">&lt;/a>&lt;/p>
&lt;p>Upon installation, AnyConnect pulls down a profile from the ASA containing several settings. This profile is in xml format and is located (on a Windows machine) at %programdata%CiscoCisco AnyConnect Secure Mobility ClientProfileAnyConnectProfile.xsd.&lt;/p>
&lt;p>To resolve this issue and connect to your VPN, open this file with notepad (or any text editor, run as admin), search for the “WindowsVPNEstablishment” tag, and modify the value. The default value is “LocalUsersOnly”, you will need to change it to “AllowRemoteUsers”. Save and close the file, then restart the machine.&lt;/p>
&lt;p>BEFORE:&lt;/p>
&lt;p>&lt;a href="https://lh3.googleusercontent.com/-izGUUyhtWyM/X33Bh8YdqGI/AAAAAAAAxuQ/rBbXsqWhe5wZYoGmjXwyyidGmu1kCNVmgCLcBGAsYHQ/image.png">&lt;img src="https://rnemeth90.github.io/wp-content/uploads/2020/10/image-17.png" alt="">&lt;/a>&lt;/p>
&lt;p>AFTER:&lt;/p>
&lt;p>&lt;a href="https://lh3.googleusercontent.com/-wFFu1JOXymQ/X33CVp0cImI/AAAAAAAAxug/fibXC6JHmkkilFtWv8641x20flapCibYACLcBGAsYHQ/image.png">&lt;img src="https://rnemeth90.github.io/wp-content/uploads/2020/10/image-18.png" alt="">&lt;/a>&lt;/p></description></item><item><title>DHCP Address Negotiation Process</title><link>https://rnemeth90.github.io/posts/2014-12-08-dhcp-address-negotiation-process/</link><pubDate>Mon, 08 Dec 2014 03:08:00 +0000</pubDate><guid>https://rnemeth90.github.io/posts/2014-12-08-dhcp-address-negotiation-process/</guid><description>&lt;p>&lt;a href="https://rnemeth90.github.io/wp-content/uploads/2014/12/2014-12-07_22h07_33.png">&lt;img src="https://rnemeth90.github.io/wp-content/uploads/2014/12/2014-12-07_22h07_33.png" alt="">&lt;/a>&lt;/p></description></item><item><title>TCP/IP Network Fundamentals</title><link>https://rnemeth90.github.io/posts/2014-11-16-tcpip-network-fundamentals/</link><pubDate>Sun, 16 Nov 2014 21:20:00 +0000</pubDate><guid>https://rnemeth90.github.io/posts/2014-11-16-tcpip-network-fundamentals/</guid><description>&lt;p>Going over the basics of network fundamentals and all the models and ideas behind them. The most pushed idea is the OSI networking model which consists of 7 layers, all of which deal with a certain aspect of the networking model.&lt;/p>
&lt;p>A P S T N D P&lt;/p>
&lt;p>From the top down this represents the following&lt;/p>
&lt;p>Layer 7: Application – This layer is the channel between software and external requests. For example, a web server would work with this layer to process HTTP requests.&lt;/p>
&lt;p>Layer 6: Presentation – This layer organizes data formats such as JPEG, Text, ASCII, etc&lt;/p>
&lt;p>Layer 5: Session – This layer deals with session control; How a conversation should start, function, and end. It can be considered the broken between the layer below and the layers above. It will ensure all the data is proper when being passed up or down.&lt;/p>
&lt;p>Layer 4: Transport – This layer is solely focused on data delivery. It deals with many protocols, but most notably it deals with TCP and UDP packets, any checksum errors, and error recovery&lt;/p>
&lt;p>Layer 3: Network – This layer deals with logical addressing and routing. It deals with the actual delivery of packets across multiple networks.&lt;/p>
&lt;p>Layer 2: Data Link – This layer deals with the rules of how data can be transmitted over a wire such as CSMA/CD and the like. It also deals with encapsulating frames to be transported over a local network&lt;/p>
&lt;p>Layer 1: Physical – The actual hardware and electrical signaling to move data over the network. Network cards, cabling, and other hardware are part of this layer&lt;/p>
&lt;p>Generic overview of the OSI model above lets work on the idea of some older and modern networks.&lt;/p>
&lt;p>Hubs – Devices that simply take a signal and regenerate it out of all ports that are connected.&lt;/p>
&lt;p>Switches – Devices that take a signal and make some sort of smart decision to provide a single path from one port to another&lt;/p>
&lt;p>Routers – Devices that make decisions based upon higher level information (logical addressing) and will make intelligent decisions on how to handle that data, both incoming and outgoing. Segments networks into two different ones.&lt;/p>
&lt;p>Bridge – A device that segments a network in two.&lt;/p>
&lt;p>Collision Domain – The bounds where a collision may occur. This is relevant for networks utilizing half-duplex communication and for older devices such as hubs.&lt;/p>
&lt;p>Broadcast Domain – The bounds where a broadcast can reach.&lt;/p>
&lt;p>Collision Domains: Forgive the visio art, it will get better… hopefully&lt;/p>
&lt;p>&lt;a href="https://rnemeth90.github.io/wp-content/uploads/2014/11/2014-11-16_16h18_36.png">&lt;img src="https://rnemeth90.github.io/wp-content/uploads/2014/11/2014-11-16_16h18_36.png" alt="">&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://xenodez.pleasedonthack.us/?attachment_id=49">&amp;lt;span style=&amp;ldquo;color: windowtext; font-family: &amp;ldquo;Verdana&amp;rdquo;,sans-serif; font-size: 9.0pt; mso-no-proof: yes; text-decoration: none; text-underline: none;&amp;quot;&amp;gt;&lt;/a>&lt;/p>
&lt;p>Every computer connected to that hub is in the collision domain noted by the circle. With a hub, the signal gets sent to every device connected to it, regardless of whether it was meant to go to that machine or not. When the PC at the top left sends information at the same time as the PC on the bottom right, a collision is likely to occur&lt;/p>
&lt;p>&lt;a href="http://xenodez.pleasedonthack.us/?attachment_id=52">&amp;lt;span style=&amp;ldquo;color: windowtext; font-family: &amp;ldquo;Verdana&amp;rdquo;,sans-serif; font-size: 9.0pt; mso-no-proof: yes; text-decoration: none; text-underline: none;&amp;quot;&amp;gt;&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://rnemeth90.github.io/wp-content/uploads/2014/11/2014-11-16_16h18_45.png">&lt;img src="https://rnemeth90.github.io/wp-content/uploads/2014/11/2014-11-16_16h18_45.png" alt="">&lt;/a>&lt;/p>
&lt;p>Every computer connected to this switch is limited in its collision domain to the port on the switch and the network card in the PC. The reason being that switches do not just take a signal and send it out of all the ports, it is intelligent enough to be able to send information directly to the PC it needs to. This is further mitigated by the fact that a computer connected to a switch may operate at full-duplex, allowing both simultaneous sending and receiving of information.&lt;/p>
&lt;p>Collisions and how they are handled:&lt;/p>
&lt;p>The way computers avoid collision in this sense is via something called CSMA/CD or Carrier Sense Multiple Access/Collision Avoidance. The way it works is this, a computer will wait until the line is silent before sending information. Every computer will listen to determine whether the line is truly clear. If two computers were to send at the same time, and a collision were to occur, the computers will immediately trigger a random back off time in which they will not try resending that information until the timer is up.&lt;/p>
&lt;p>Unicast vs Broadcast vs Multicast&lt;/p>
&lt;p>The idea between these concepts is fairly simple. Unicast deals with a transmission that is intended for one recipient. A broadcast is a transmission that is meant for all recipients that are able to hear it. Multicast is intended for a specific group of recipients.&lt;/p></description></item><item><title>Layer 2 Switching Fundamentals</title><link>https://rnemeth90.github.io/posts/2012-11-16-layer-2-switching-fundamentals/</link><pubDate>Fri, 16 Nov 2012 21:26:00 +0000</pubDate><guid>https://rnemeth90.github.io/posts/2012-11-16-layer-2-switching-fundamentals/</guid><description>&lt;p>Switches are devices that support a large number of ports to connect devices to the network.&lt;/p>
&lt;h3 id="design" >Design:
&lt;span>
&lt;a href="#design">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>&lt;a href="https://rnemeth90.github.io/wp-content/uploads/2014/11/2014-11-16_16h22_54.png">&lt;img src="https://rnemeth90.github.io/wp-content/uploads/2014/11/2014-11-16_16h22_54.png" alt="">&lt;/a>&lt;/p>
&lt;p>More towards a CCNP or CCDA topic, but designing a network when it comes to the switching side can be done in three building blocks. The access layer, the distribution layer, and the core layer. The access layer generally has a high port density, can support VLANs, QoS, and access lists. The distribution layer will aggregate multiple access layer switches. These are also generally Layer 3 switches to allow routing among an enterprise. It will need to be able to handle the volume of traffic in addition to supporting the same features as the access layer switches. The core layer is the device which will need the highest bandwidth backplane to deal with all of the traffic.&lt;/p>
&lt;h3 id="how-switches-handle-traffic" >How switches handle traffic:
&lt;span>
&lt;a href="#how-switches-handle-traffic">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>A switch is an intelligent device that can make some decisions on how to handle the data it is given. Switches can be divided into two categories for these decisions: Layer 2 or Layer 3 switches. For the CCNA we will only be interested in the layer 2 switches. Layer 2 switches operate at the data link layer. This layer deals primarily with MAC addresses. A Layer 2 switch will build a CAM table full of dynamically learned MAC addresses. The way it learns these addresses is by inspecting the layer 2 header/trailer and learning the source MAC addresses on the frames it receives. A frame is what a packet is encapsulated in when it moves from device to device across the network.&lt;/p>
&lt;p>&lt;a href="https://rnemeth90.github.io/wp-content/uploads/2014/11/2014-11-16_16h23_04.png">&lt;img src="https://rnemeth90.github.io/wp-content/uploads/2014/11/2014-11-16_16h23_04.png" alt="">&lt;/a>&lt;/p>
&lt;p>With this example the switch has learned PC1/PC2/and PC3′s MAC addresses. If a packet came in on Fa0/4 from PC4, the switch would look at the source MAC address and put an entry for 4444.4444.4444 on Fa0/4. A switch will route traffic based on this table. There are a few decisions it must make to determine how to handle traffic. When it first receives a frame it will consult it’s CAM table to determine whether or not it has the source MAC address listed for that port. If not, it will add it to the CAM table. In the example above, PC1 sent a frame to the switch, the switch noticed PC1′s MAC address was not in it’s table and added it. The next thing it looks at is the destination MAC address. The CAM table is again consulted. If it finds a match the switch will send the frame directly to the recipient it needs to on whatever port it is on. In the example above, PC1 sends a frame to PC3. Because the switch sees 1111.1111.1111 sending to 3333.3333.3333 and has an entry for 3333.3333.3333 it will send the frame out of port Fa0/3 to the recipient. If a destination is not in the CAM table the switch will need to try to find the recipient. In this case the switch will decide to broadcast the frame out of every port EXCEPT the one it came in on. In this example, PC1 sends a frame destined for PC4. The switch will see a frame from 1111.1111.1111 to 4444.4444.4444. PC4′s MAC address is not in it’s table. The switch will then send the frame out of every port except for Fa0/1 (the source). When PC2 and PC3 get this frame, it will determine if the frame was meant for it, and if not it will ignore it. PC4 will also make the same decision and PC4 will respond. Once PC4 has responded the switch will be able to add PC4′s MAC address to it’s table on Fa0/4.&lt;/p></description></item></channel></rss>