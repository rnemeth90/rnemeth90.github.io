<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Powershell on GeekyRyan</title><link>https://rnemeth90.github.io/tags/powershell/</link><description>GeekyRyan (Powershell)</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 15 Aug 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://rnemeth90.github.io/tags/powershell/index.xml" rel="self" type="application/rss+xml"/><item><title>Using try/catch/finally Blocks in PowerShell</title><link>https://rnemeth90.github.io/posts/2023-08-15-powershell-try-catch/</link><pubDate>Tue, 15 Aug 2023 00:00:00 +0000</pubDate><guid>https://rnemeth90.github.io/posts/2023-08-15-powershell-try-catch/</guid><description>&lt;p>Despite being a great language, PowerShell is not impervious to errors. Errors that occur within your code can stop it&amp;rsquo;s execution or even cause unexpected changes in the resources that your script is managing. Learning to handle these errors gracefully is the foundation of defensive coding. Today, we&amp;rsquo;ll take a quick look at how PowerShell handles errors with Try-Catch-Finally blocks. They allow you to gracefully handle errors and perform cleanup operations, ensuring that your script doesn&amp;rsquo;t crash when the unexpected occurs. We&amp;rsquo;ll then cover the differences in terminating and non-terminating errors and why you should take these into consideration when implementing error handling.&lt;/p>
&lt;h2 id="the-try-block" >The Try Block
&lt;span>
&lt;a href="#the-try-block">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>The Try block is where you place the code that might generate an error. Think of it as a protective bubble around your potentially troublesome code. If an error occurs within the Try block, PowerShell will immediately jump to the corresponding Catch block.&lt;/p>
&lt;p>Here&amp;rsquo;s a simple example:&lt;/p>
&lt;pre tabindex="0">&lt;code>try {
# Code that might generate an error
Get-Item -Path &amp;#34;NonexistentFile.txt&amp;#34;
}
catch {
# Code to handle the error
Write-Host &amp;#34;An error occurred: $_&amp;#34;
}
&lt;/code>&lt;/pre>&lt;h2 id="the-catch-block" >The Catch Block
&lt;span>
&lt;a href="#the-catch-block">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>The Catch block is where you can handle the error. PowerShell provides you with a special variable $_ that contains information about the error. You can use this variable to display error messages or even take corrective actions.&lt;/p>
&lt;p>In the example above, we&amp;rsquo;re capturing the error generated by attempting to retrieve a nonexistent file. The $_ variable holds the error message, which we&amp;rsquo;re displaying using Write-Host.&lt;/p>
&lt;h2 id="the-finally-block" >The Finally Block
&lt;span>
&lt;a href="#the-finally-block">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Now, let&amp;rsquo;s talk about the unsung hero – the Finally block. This block is executed regardless of whether an error occurred or not. It&amp;rsquo;s where you can place cleanup code that ensures your script leaves no trace behind, even in the face of adversity. Some tasks that are commonly done in the finally block are closing database connections, removing temp files, etc. The finally block is completely optional.&lt;/p>
&lt;pre tabindex="0">&lt;code>
try {
# Code that might generate an error
# ...
}
catch {
# Code to handle the error
# ...
}
finally {
# Cleanup code here
# ...
}
&lt;/code>&lt;/pre>&lt;h2 id="terminatingnon-terminating-errors" >Terminating/non-terminating Errors
&lt;span>
&lt;a href="#terminatingnon-terminating-errors">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>non-terminating errors are any error that will not stop the execution of your script. Most cmdlets in PowerShell are non-terminating. They may output an error, but your script will continue to run. These kinds of errors cannot be caught with a catch block by default. The reason for this is the default &lt;code>ErrorAction&lt;/code> in your PowerShell profile, which is set to &lt;code>Continue&lt;/code>.&lt;/p>
&lt;pre tabindex="0">&lt;code># To show your default error action type
$ErrorActionPreference
&lt;/code>&lt;/pre>&lt;p>Let&amp;rsquo;s go back and look at our first example:&lt;/p>
&lt;pre tabindex="0">&lt;code>try {
# Code that might generate an error
Get-Item -Path &amp;#34;NonexistentFile.txt&amp;#34;
}
catch {
# Code to handle the error
Write-Host &amp;#34;An error occurred: $_&amp;#34;
}
&lt;/code>&lt;/pre>&lt;p>If you took the time to run this code, you may have noticed that the &lt;code>Write-Host&lt;/code> cmdlet in the &lt;code>catch&lt;/code> block was never ran. Why did we get a red error message in our PowerShell console, rather than the text &lt;code>An error occurred: ...&lt;/code>? The reason is that the non-existing path isn&amp;rsquo;t a terminating error, and the default &lt;code>ErrorAction&lt;/code> is &lt;code>Continue&lt;/code>. To catch the error, you will need to change the &lt;code>ErrorAction&lt;/code> in your PowerShell console to &lt;code>Stop&lt;/code>. This can be done in multiple ways. You can add &lt;code>-ErrorAction Stop&lt;/code> to the cmdlet, like this:&lt;/p>
&lt;pre tabindex="0">&lt;code>try {
# Code that might generate an error
Get-Item -Path &amp;#34;NonexistentFile.txt&amp;#34; -ErrorAction Stop
}
catch {
# Code to handle the error
Write-Host &amp;#34;An error occurred: $_&amp;#34;
}
&lt;/code>&lt;/pre>&lt;p>Or you can change the &lt;code>ErrorActionPreference&lt;/code> for the entire script, by adding this to the top of the script:&lt;/p>
&lt;pre tabindex="0">&lt;code>$ErrorActionPreference = &amp;#34;Stop&amp;#34;
&lt;/code>&lt;/pre>&lt;h2 id="exceptions" >Exceptions
&lt;span>
&lt;a href="#exceptions">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>If you have ever worked with exceptions in C# you can skip this section. In the previous examples, we used simple &lt;code>catch&lt;/code> blocks that will catch &lt;em>any&lt;/em> error. This is a good start, but we can do better. PowerShell allows you to catch individual exceptions based on the exception type, similar to how C# handles catching exceptions.&lt;/p>
&lt;p>Let&amp;rsquo;s look at an example:&lt;/p>
&lt;pre tabindex="0">&lt;code>try {
# Attempt to open a non-existent file
$file = Get-Content -Path &amp;#34;NonexistentFile.txt&amp;#34;
}
catch [System.IO.FileNotFoundException] {
Write-Host &amp;#34;Caught a FileNotFoundException: $_&amp;#34;
}
catch {
Write-Host &amp;#34;Caught an exception: $_&amp;#34;
}
&lt;/code>&lt;/pre>&lt;p>We now have two &lt;code>catch&lt;/code> blocks. If we encounter an exception of type &lt;code>System.IO.FileNotFoundException&lt;/code>, the first &lt;code>catch&lt;/code> block will catch the exception and handle it accordingly. The second &lt;code>catch&lt;/code> block will handle any other generic error.&lt;/p>
&lt;h2 id="conclusion" >Conclusion
&lt;span>
&lt;a href="#conclusion">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Error handling might seem daunting at first, but with the power of Try-Catch-Finally blocks at your fingertips, you&amp;rsquo;re well-equipped to handle errors gracefully and ensure the resilience of your PowerShell scripts. Remember, every error is an opportunity to refine your skills and make your scripts more robust.&lt;/p>
&lt;p>Thanks for reading!&lt;/p>
&lt;p>Official Microsoft Documentation for Try-Catch-Finally in PowerShell:
&lt;a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_try_catch_finally?view=powershell-7.3">about_try_catch_finally&lt;/a>&lt;/p></description></item><item><title>Powershell for Devops - Querying REST APIs with Powershell</title><link>https://rnemeth90.github.io/posts/2022-08-04-querying-rest-with-powershell/</link><pubDate>Thu, 04 Aug 2022 00:00:00 +0000</pubDate><guid>https://rnemeth90.github.io/posts/2022-08-04-querying-rest-with-powershell/</guid><description>&lt;p>This will be a short post on querying REST APIs with Powershell.&lt;/p>
&lt;p>It&amp;rsquo;s hard to argue that REST APIs are the predominant technology for interacting
with networked services. They provide a gateway for interacting with a 3rd party (or self-hosted)
product without having to go through the exercise of a more complicated integration. REST APIs communicate
in a common format, typically JSON. However, most will allow us to choose the response format by specifying an
option in the &amp;lsquo;Accept&amp;rsquo; header. Most languages provide a native method for interacting with
REST APIs. This objective for this post is to show you how simple this is with Powershell.&lt;/p>
&lt;p>To get started, we&amp;rsquo;ll need a public API to interact with. I&amp;rsquo;m going to use &lt;a href="https://icanhazdadjoke.com/">https://icanhazdadjoke.com/&lt;/a>, because
there is no authentication and no rate-limiting (two concepts we will cover in another post).&lt;/p>
&lt;p>Calling the API is extremely simple:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Powershell" data-lang="Powershell">&lt;span style="display:flex;">&lt;span>$url = &lt;span style="color:#e6db74">&amp;#34;https://icanhazdadjoke.com/&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Invoke-RestMethod -Uri $url -Method Get
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>However, this results in the content being returned as plain text. This isn&amp;rsquo;t ideal.&lt;/p>
&lt;p>Let&amp;rsquo;s pass the &amp;lsquo;Accept&amp;rsquo; header to tell the API the format we are expecting to be returned:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Powershell" data-lang="Powershell">&lt;span style="display:flex;">&lt;span>$url = &lt;span style="color:#e6db74">&amp;#34;https://icanhazdadjoke.com/&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$headers = @{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;Accept&amp;#39;&lt;/span> = &lt;span style="color:#e6db74">&amp;#39;application/json&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Invoke-RestMethod -Uri $url -Method Get -Headers $headers
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Output:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Powershell" data-lang="Powershell">&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#ae81ff">15&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span>&lt;span style="color:#ae81ff">04&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span>&lt;span style="color:#ae81ff">34&lt;/span>] C:\..\..\rnemeth90.github.io on &lt;span style="color:#960050;background-color:#1e0010">&lt;/span>main &lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#ae81ff">+1&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">❯&lt;/span> Invoke-RestMethod -Uri $url -Method Get -Headers $headers
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>id joke status
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-- ---- ------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>3LmyXvsPfqc I don&lt;span style="color:#e6db74">&amp;#39;t trust stairs. They&amp;#39;&lt;/span>re always up to something. &lt;span style="color:#ae81ff">200&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>That looks a little better. For those of you familiar with Powershell, the output above probably
looks completely normal. But for those not-so-familiar with Powershell, or those expecting
more of a &amp;lsquo;json-esk&amp;rsquo; output, this may look a bit&amp;hellip; weird.&lt;/p>
&lt;p>Powershell is an object oriented language. &lt;strong>Everything is an object&lt;/strong> in Powershell, even the response
of this request. What you see in the output is simply the properties of the object.&lt;/p>
&lt;p>Luckily Powershell provides us with a cmdlet to convert an object into json (aptly named: ConvertTo-Json). We can use it like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Powershell" data-lang="Powershell">&lt;span style="display:flex;">&lt;span>$url = &lt;span style="color:#e6db74">&amp;#34;https://icanhazdadjoke.com/&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$headers = @{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;Accept&amp;#39;&lt;/span> = &lt;span style="color:#e6db74">&amp;#39;application/json&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Invoke-RestMethod -Uri $url -Method Get -Headers $headers | ConvertTo-Json
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Here we are piping the output from Invoke-RestMethod to ConvertTo-Json. Pretty neat!&lt;/p>
&lt;p>Output:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Powershell" data-lang="Powershell">&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#ae81ff">15&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span>&lt;span style="color:#ae81ff">04&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span>&lt;span style="color:#ae81ff">35&lt;/span>] C:\..\..\rnemeth90.github.io on &lt;span style="color:#960050;background-color:#1e0010">&lt;/span>main &lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#ae81ff">+1&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">❯&lt;/span> Invoke-RestMethod -Uri $url -Method Get -Headers $headers | Convertto-json
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;id&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;AAdFBXnGlyd&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;joke&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;If you walk into a forest and cut down a tree, but the tree doesn&amp;#39;t understand why you cut it down, do you think it&amp;#39;s stumped?&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;status&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> &lt;span style="color:#ae81ff">200&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now, that looks more normal.&lt;/p>
&lt;p>There is much more we can do with Invoke-RestMethod. The &amp;lsquo;Method&amp;rsquo; parameter of this cmdlet accepts any of the common
HTTP methods (GET, PUT, PATCH, DELETE, POST, HEAD). You can also specify other headers and a body (using the -body parameter).&lt;/p>
&lt;p>Both of these parameters accept dictionaries:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Powershell" data-lang="Powershell">&lt;span style="display:flex;">&lt;span>$url = &lt;span style="color:#e6db74">&amp;#34;https://icanhazdadjoke.com/&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$headers = @{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;Accept&amp;#39;&lt;/span> = &lt;span style="color:#e6db74">&amp;#39;application/json&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;Host&amp;#39;&lt;/span> = &lt;span style="color:#e6db74">&amp;#39;MyServer&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$body = @{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;Eat&amp;#39;&lt;/span> = &lt;span style="color:#e6db74">&amp;#39;Pizza&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Invoke-RestMethod -Uri $url -Method Get -Headers $headers -Body $body | ConvertTo-Json
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Unfortunately I won&amp;rsquo;t be able to show the other HTTP methods, as this API only supports GET requests. So that&amp;rsquo;s all for now.&lt;/p></description></item><item><title>Remove Kubernetes Namespace Stuck in the Terminating State</title><link>https://rnemeth90.github.io/posts/2022-06-04-remove-kubernetes-namespace-stuck-in-the-terminating-state/</link><pubDate>Sat, 04 Jun 2022 18:29:41 +0000</pubDate><guid>https://rnemeth90.github.io/posts/2022-06-04-remove-kubernetes-namespace-stuck-in-the-terminating-state/</guid><description>&lt;p>In this post, we will discuss how to remove a Kubernetes namespace that is stuck in the ‘terminating’ state.&lt;/p>
&lt;p>A namespace is like a container. You can use it to store related objects in a Kubernetes environment. Maybe you are hosting a blog in Kubernetes. This blog will likely have a database, a frontend website, a load balancer (service) to spread the incoming traffic among ‘x’ number of frontend containers (pods), and maybe some middle-tier or utility applications. One day, you decide you no longer want this blog, so you plan to delete it. Rather than tediously deleting all of the various entities associated with this blog, you can delete the namespace that contains these entities. This will essentially ‘cascade delete’ the resources within the namespace as well.&lt;/p>
&lt;p>After deleting the namespace for your blog, you notice that it still exists, but the state of it is ‘Terminating’, and it has been like this for a long time (hours or maybe even days).&lt;/p>
&lt;p>&lt;a href="https://geekyryan.com/wp-content/uploads/2022/06/image.png">&lt;/a>&lt;/p>
&lt;p>Kubernetes will occassionally fail to delete third-party resources when deleting a namespace, causing the namespace to linger. This can happen if the third-party API managing the resource is not responding to requests. To verify if any of these resources still exist, use this command:&lt;/p>
&lt;pre tabindex="0">&lt;code>kubectl api-resources --verbs=list --namespaced -o name | xargs -n 1 kubectl get --show-kind --show-all --ignore-not-found -n &amp;lt;terminating-namespace&amp;gt;
&lt;/code>&lt;/pre>&lt;p>If you happen to see any resources in the output, you can try force deleting them and then try to delete the namespace again.&lt;/p>
&lt;p>In my experience, the majority of the time you will not find any resources still hanging around. Rather, the namespace will be completely empty. What is going on here?&lt;/p>
&lt;p>Let’s take a look at the namespace:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">$ kubectl get namespace darn-c101 -o yaml&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-YAML" data-lang="YAML">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Namespace&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">annotations&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">kubectl.kubernetes.io/last-applied-configuration&lt;/span>: &lt;span style="color:#ae81ff">|&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">kubernetes.io/metadata.name&lt;/span>: &lt;span style="color:#ae81ff">darn-c101&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">finalizers&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">kubernetes&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">status&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">conditions&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">lastTransitionTime&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;2022-06-01T19:05:31Z&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">message: &amp;#39;Some content in the namespace has finalizers remaining&lt;/span>: &lt;span style="color:#ae81ff">darn-c101.geekyryan.io/finalizer in 1 resource instances&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">reason&lt;/span>: &lt;span style="color:#ae81ff">SomeFinalizersRemain&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">status&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;True&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">type&lt;/span>: &lt;span style="color:#ae81ff">NamespaceFinalizersRemaining&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">phase&lt;/span>: &lt;span style="color:#ae81ff">Terminating&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Notice the inclusion of the finalizers field in the above JSON. Some namespaces have a finalizer defined under spec.&lt;/p>
&lt;p>A finalizer is a special metadata key that tells Kubernetes to wait until a specific condition is met before it fully deletes a resource. Much like a finalizer in the .NET framework (does Java have those too? 😀 )&lt;/p>
&lt;p>So when you run a command like &lt;code>kubectl delete namespace &amp;lt;namespace&amp;gt;&lt;/code>, Kubernetes checks for a finalizer in the &lt;code>metadata.finalizers&lt;/code> field. If the resource defined in the finalizer cannot be deleted, then the namespace is not deleted either. This puts the namespace into a perpetual terminating state and is never actually deleted.&lt;/p>
&lt;p>When an object has been terminating for an excessive time, check its finalizers by inspecting the &lt;code>metadata.finalizers&lt;/code> field in its YAML.&lt;/p>
&lt;p>So we now know what the problem is. How can we solve it? Well, it’s actually quite simple. If you are using bash, use this script:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>namespaces&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>kubectl get ns --field-selector&lt;span style="color:#f92672">=&lt;/span>status.phase&lt;span style="color:#f92672">==&lt;/span>Terminating -o jsonpath&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;{range .items[*]}{.metadata.name}{&amp;#34;\n&amp;#34;}{end}&amp;#39;&lt;/span>&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[&lt;/span> -z &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$namespaces&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;No namespaces to delete.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exit
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> namespace in $namespaces
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;[Removing Namespace]: &lt;/span>$namespace&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kubectl get namespace $namespace -o json | tr -d &lt;span style="color:#e6db74">&amp;#34;\n&amp;#34;&lt;/span> | sed &lt;span style="color:#e6db74">&amp;#34;s/\&amp;#34;finalizers\&amp;#34;: \[[^]]\+\]/\&amp;#34;finalizers\&amp;#34;: []/&amp;#34;&lt;/span> | kubectl replace --raw /api/v1/namespaces/$namespace/finalize -f - &amp;gt; /dev/null 2&amp;gt;&amp;amp;&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://gist.github.com/rnemeth90/e83bb4c8808f0d28412cb40edb2487d3">Delete Terminating Kubernetes Namespaces with Bash (github.com)&lt;/a>&lt;/p>
&lt;p>It will search for any namespace that is stuck in the terminating state and forcefully remove it by removing the finalizers field and then using &lt;code> kubectl replace&lt;/code> to commit the change back to the Kube API.&lt;/p>
&lt;p>If you prefer Powershell, you can use this script:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Powershell" data-lang="Powershell">&lt;span style="display:flex;">&lt;span>$terminatingNamespaces = kubectl get ns --field-selector=status.phase==Terminating -o jsonpath=&lt;span style="color:#e6db74">&amp;#34;{range .items[*]}{.metadata.name}{&amp;#39;\n&amp;#39;}{end}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">foreach&lt;/span> ($ns &lt;span style="color:#66d9ef">in&lt;/span> $terminatingNamespaces) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Write-Verbose &lt;span style="color:#e6db74">&amp;#39;[FOUND]: Forcefully removing $ns&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> $jsonObj = kubectl get namespace $ns -o json | ConvertFrom-Json | foreach-object { $_.spec.finalizers = @(); $_ } |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> convertto-json | kubectl replace --raw /api/v1/namespaces/$namespace/finalize &lt;span style="color:#f92672">-f&lt;/span> -
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://gist.github.com/rnemeth90/19d7de622a5009c1cf908c5d4deb5358">Delete Terminating Kubernetes Namespaces with Powershell (github.com)&lt;/a>&lt;/p>
&lt;p>It does the same thing as the bash script, just in more of a Window-zy way.&lt;/p>
&lt;p>It’s that simple. I hope this was helpful. If you have any questions, comments, or concerns, please feel free to reach out.&lt;/p></description></item></channel></rss>